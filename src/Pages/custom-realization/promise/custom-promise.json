{
	"promiseIterative": "\nconst promiseAllIterative = (promises) => {\n\t// method returns promise\n \treturn new Promise((resolve, reject) => {\n\t\t// resolved promises\n\t\tlet results = [];\n\t\t// count for resolved promises\n\t\tlet completed = 0;\n\n\t\tpromises.forEach((promise, index) => {\n\t\t\t// resolve each promise\n\t\t\tPromise.resolve(promise).then((result) => {\n\t\t\t\tresults[index] = result;\n\t\t\t\tcompleted += 1;\n\t\t\t\t// compare completed promises with income promises\n\t\t\t\tif(completed === promises.length){\n\t\t\t\t\tresolve(results);\n\t\t\t\t}\n\t\t\t\t// show error \n\t\t\t}).catch((error) => reject(error));\n\t\t});\n\t});\n};\n",
	"promise": "class CustomPromise {\n  constructor(callback) {\n    this.promiseChain = [];\n\n    this.errorCallback = () => {};\n\n    this.finallyCallback = () => {};\n\n    try {\n      callback.call(\n        null,\n        this.customResolve.bind(this),\n        this.customReject.bind(this)\n      );\n    } catch (err) {\n      this.errorCallback(err);\n    } finally {\n      this.finallyCallback();\n    }\n  }\n\n  customResolve(data) {\n    this.promiseChain.forEach((func) => (data = func(data)));\n  }\n\n  customReject(err) {\n    this.errorCallback(err);\n  }\n\n  then(callback) {\n    this.promiseChain.push(callback);\n    return this;\n  }\n\n  catch(callback) {\n    this.errorCallback = callback;\n    return this;\n  }\n\n  finally(callback) {\n    this.finallyCallback = callback;\n    return this;\n  }\n}"
}
